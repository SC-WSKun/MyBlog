---
title: 计算机图形学与虚拟现实
date: 2021-09-09 19:00:31
tags: 计算机图形学
categories: 我的笔记
---

# 图形学的一些概念

## 计算机图形学

### 计算机图形学与计算机视觉、图像处理的关系

![image-20211215004139961](https://cdn.jsdelivr.net/gh/SC-WSKun/HexoStaticFile/img/image-20211215004139961.png)

### 计算机图形学的应用

四个主要领域：

> - 信息的显示
> - 设计
> - 仿真和动画
> - 用户界面

举例：

>- 制造工业（CAD）
>- 娱乐业（影视、游戏）
>- 数据工业（各种可视化）
>- 科学研究（物理仿真、三维重建等）
>- 教育、医学、艺术、军事
>- ...

## 图形绘制流水线

### 图形绘制流水线基本环节、作用、变换

输入：顶点

1. 顶点处理：建模器将顶点转换成几何对象
2. 裁剪和图元组装：确定哪些几何对象可以在屏幕上显示，并把明暗值或颜色值赋给这些对象的顶点，将没有裁减掉的图元送入光栅化模块中 
3. 光栅化：我们可以通过光栅化来生成一组片元，来说明顶点所对应的像素在帧缓存中的位置
4. 片元处理：对顶点的颜色值及顶点的纹理坐标进行插值计算，

输出：像素

## 虚拟现实/增强现实/混合现实

1. 虚拟现实

   >使用虚拟化技术制造出一个完全虚拟的世界来取代现实世界

- 虚拟现实的几个要素

  1. 多感知性
     - 视觉、听觉、触觉、运动、味觉、嗅觉等感知

  2. 沉浸感
     - 用户感到作为主角存在于模拟环境中
     - 理想的模拟环境应达到用户难辨真假的程度

  3. 交互性
     - 用户可操作性虚拟环境内物体，并获得反馈

  4. 自主性
     - 指虚拟环境中物体依据物理定律进行动作的程度

2. 增强现实

   > 使用信息技术对现实世界的一种补充和加强

3. 混合现实

   >用户可以看到真实世界也可以看到虚拟的物体，并且用户可以与虚拟的物体进行互动



## 图形系统*

- 输入设备
- 中央处理单元
- 图形处理单元
- 存储器
- 帧缓存
- 输出设备

# 扫描转换

## 几何图元的扫描转换

应用程序---（顶点）--->图形系统----（像素）----->帧缓存

## 最优点集

点到直线上距离最小 == 某一行（列）上的点中到直线距离最小的点

斜率小于 1 按列，大于 1 按行

# 线段扫描转换

## DDA 算法*

### 平凡算法

```
x 取固定间隔的点

y 用 mx+i 计算

用像素点(x,round(y))逼近上述点(x,y)
```

### 平凡算法的缺点

多次乘法运算，取整运算

### 平凡算法的优化（DDA 算法）

```
yi+1 = yi + 斜率 m
```

## Bresenham 算法*

### 记号

```
1. 设线段两个端点，（X0，Y0），（X1，Y1）

2. 设 x1 - x0 > 0, y1 - y0 > 0

3. 记斜率 m，约定 m<1

4. 线段上(xi,yi)的近似点为（上面加横杠）
```

### 判断准则计算

计算点到上下点的距离，取距离最小的点

pi 代表下减上

### p0 的计算

- p0 = 2△y - △x

### pi 的计算(已知 pi 推出 pi+1)

- pi+1 - pi = 2△y - 2△x（yi+1-yi)

### 算法流程

```
1. 画（x0,y0），计算△x，△y，p0
2. 如果 𝑝𝑖≤0 画(𝑥𝑖+1,𝑦𝑖)
    计算 𝑝(𝑖+1)=𝑝𝑖+𝑎

```

示例代码：

```
void lineBresenham(int x0,int y0,int x1,int y1)
{
    int temp;
    if (x1 < x0){
         temp = x0;  x0 = x1; x1 = temp;
         temp = y0;  y0 = y1; y1 = temp;
    }

   int  k, dx = x1-x0 , dy = y1-y0;
    int  Twody = 2*dy, Twody_Twodx = 2*dy-2*dx, p= Twody-dx;
    glPointSize(5); glColor3f(1,0,0);
    glBegin(GL_POINTS);
    for (k = 0; k <= dx; k++){
          glVertex2i(x+k, y);
          if(p <= 0)
                p += Twody;
          else {
                y++;
                p += Twody_Twodx;
          }
    }
    glEnd()；
}
```

## 走样与反走样

- 给周围的点增加颜色，距离近的比较深

## 光栅图形

- 光栅图形的本质是点阵表示

### 真实感图形

- 面着色

- 画面明暗自然、色彩丰富

- 比线框图更真实、生动

### 基本概念

```
1. 简单多边形（无自相交）
2. 图形学中多边形的两种表示方式
   a. 顶点表示
   优点：直观，有几何意义
   不足：不能直接用于多边形着色
   b. 点阵表示
   优点：可用帧缓冲器表示图形、支持面着色
   不足：无几何信息
```

## 多边形区域的点阵表示

### 内部表示

由一堆点组成，相邻点颜色相同即视为同意区域

### 边界表示

相同颜色边界点围成的区域，里面视为同一区域

## 邻接关系

- 四连通邻域：一个像素有四个相邻象素
- 八连通邻域：一个像素有八个相邻象素
- 四连通区域的边界是八连通区域，八连通区域的边界是四连通区域

## 种子填充算法*

### 四连通算法

```
Fill_Boundary_4_Connnected(x, y, G0, G1){
// (x,y) 种子像素的坐标；
// G0 边界像素颜色； G1 需要填充的内部像素颜色
	if(GetPixel(x,y) != G0 && GetPixel(x,y)!= G1){
   	 // GetPixel(x,y): 返回像素(x,y)
		SetPixel(x, y, G1); // 将像素(x, y)置成填充颜色
    	Fill_Boundary_4Connnected(x, y+1, G0, G1)；
		Fill_Boundary_4Connnected(x, y-1, G0, G1)；
		Fill_Boundary_4Connnected(x-1, y, G0, G1)；
		Fill_Boundary_4Connnected(x+1, y, G0, G1)；
	}
}
```

### 八连通算法



## 逐点判断算法

从点引出一条射线，与区域交点个数为奇数个，则点在区域内；偶数时，在区域外。

特殊情况：判断边界位于射线的哪一侧

## 多边形扫描转换算法*

> 如何与消隐算法结合？
>
> 如何与绘制模式结合？

### Brute-force scan-line 算法

利用连贯性优化算法（活性边表多边形扫描填充算法，适用于直线多边形）

连贯性：

- 区域连贯性
- 扫描线的连贯性

效率提高：逐点判断->区间判断

![image-20211216105136745](https://cdn.jsdelivr.net/gh/SC-WSKun/HexoStaticFile/img/image-20211216105136745.png)

![image-20211216105148687](https://cdn.jsdelivr.net/gh/SC-WSKun/HexoStaticFile/img/image-20211216105148687.png)

### 极值点

(yi-1 - yi)(yi+1 - yi) > 0

### 非极值点

(yi-1 - yi)(yi+1 - yi) < 0

扫描线在通过非极值点P时，砍掉一截

### 数据结构

- 排序的边表ET：记录多边形信息，便于判断是否与扫描线相交
- 活化边表AEL：记录当前扫描线信息，便于与扫描线求交

```
struct ET{
    float ymax;
    float x;
    float dx;
    ET *next;
}
```

# Clipping

> 对于视见体之外的对象进行光栅化处理会影响系统的绘制效率，因为这些对象根本就不可见。

## Sutherland-Cohen裁剪算法

> 二维：
>
> - Sutherland-Cohen 裁剪：将裁剪窗口的四条边无线延长，将空间分为9个区域，每个区域赋一个唯一的二进制编码，对线段两个端点进行编码，得到O1，O2
>
> - 窗口编码
>
>   ![image-20211215153551252](https://cdn.jsdelivr.net/gh/SC-WSKun/HexoStaticFile/img/image-20211215153551252.png)
>
> - 重点分割裁剪：除以2，移位运算
>
> 总共有四种情况：
>
> 1. O1 == O2 == 0： 整条线段处于裁剪窗口之内，所以需要把该线段送入光栅化模块进行光栅化处理
> 2. O1 != 0 & O2 == 0（或相反）：非零的编码代表线段与裁剪窗口的哪条边相交，需要计算出交点，计算出来后还要计算交点的编码，从而确定是否需要另一个求交运算
> 3. O1 & O2 != 0：需要对线段的两个端点编码进行按位与运算，可以确定两个端点是否位于裁剪窗口某条裁剪边的同一侧，如果满足这个条件，则可以直接丢弃该线段
> 4. O1 & O2 == 0：需要计算出线段与裁剪窗口某边的交点，再根据新的交点编码继续判断

> 三维：

## Sutherland-Hodgeman多边形裁剪

> 二维：
>
> - 裁剪窗口和被裁剪对象：多边形
> - 对每条边作线裁剪：线裁剪，设定裁剪窗口当前边的值，比如ymax，则可以得到（x1,x2) =>（xi,ymax）利用相似三角形可以快速求出xi
> - Sutherland-Hodgman 多边形裁剪:必须是凸多边形
>
> 流程图（例子）
>
> 输入 => 顶边裁剪 => 底边裁剪 => 右边裁剪 => 左边裁剪 => 结果

> 三维：

```
顶点分类：
被裁剪多边形的顶点
裁剪窗口的顶点
两多边形的交点

边的分类：
被裁剪多边形的边
裁剪窗口的边
```

## 三维裁剪窗口的规范化

### 一般情形

- 棱台->正方形
- 张角为45度时

![image-20211021190952264](https://cdn.jsdelivr.net/gh/SC-WSKun/HexoStaticFile/img/image-20211021190952264.png)

# 几何变换

![image-20211215020958252](C:\Users\flyingfeather\AppData\Roaming\Typora\typora-user-images\image-20211215020958252.png)

## 二维几何变换
- 齐次坐标
```
(x,y)=>(x,y,1)
引入齐次坐标的意义是合并矩阵中的乘法和加法
```
- 基本变换
```
1. 平移
2. 旋转
3. 放缩
4. 组合变换
```


## 三维几何变换
### 坐标变换流程
- 局部坐标系
- 造型变换
- 世界坐标系
- 取景变换
- 视点坐标系
- 投影变换
- 图像坐标系
- 设备变换
- 规格化设备坐标系
- 视窗变换
- 屏幕坐标系

![image-20211215023754255](https://cdn.jsdelivr.net/gh/SC-WSKun/HexoStaticFile/img/image-20211215023754255.png)

### 三维旋转变换
```
1. 平移
4. 绕任意直线旋转
    1. 作变换让l与z轴重合
    2. 绕z轴旋转
    3. 逆变换使l回原位
```

## 观察坐标系设定方式
- 视点：定义域视点坐标系OXYZ中
- 视点定义参数：视点位置、观察方向
- 世界坐标中定义视点坐标系
  1. 坐标原点
  2. 镜头朝向（坐标系与镜头方向相反）
- 轴灭点：与坐标轴平行的直线的投影交于一点
- 透视投影类型：根据灭点数分类
  1. 一点透视投影
  2. 两点透视投影
  3. 三点透视投影
- 视点设置函数
  ```
  void gluLookAt(GLdouble eyex,GLdouble eyey,GLdouble eyez,GLdouble centerx,GLdouble centery,GLdouble centerz)
  ```
  设置正轴侧投影
  ```
  设视点C为（a,a,a）
  视线方向与n=(1,1,1)相反
  根据需要取up=(upx,upy,upz)
  ```
- OpenGL透视投影使用库函数
- glFrustum()的变换矩阵
    glFrustum把视棱台转换成立方体
- gluPerspective(GLdouble fovy,GLdouble aspect,GLdouble zNear)
- glOrtho(left,right,bottom,top,near,far)：正交投影



# 消隐算法

## 基本概念

> **消隐可提高绘制效率，但会降低绘制质量**

- 排序：对场景中物体按其到视点的远近排序
- 连贯性：同一区域像素往往有相似性质
- 以上两者决定了消隐的概率

## 消隐算法分类

- 按输出形式：
  1. 线消隐
  2. 面消隐

- 按消隐空间：
  1. 按图像空间消隐
  2. 景物空间消隐/对象空间消隐

- 图像空间消隐算法框架（HSR）

  ![image-20211021191752835](https://cdn.jsdelivr.net/gh/SC-WSKun/HexoStaticFile/img/image-20211021191752835.png)

## 对象空间算法特点

- 复杂度：O（n^2）
- 裁剪是特殊的消隐
- 后向面剔除

## 消隐假设

- 场景由多边形面构成
- 场景经过变换后，离视点越远，z值越大（裁剪窗口规范化）
- 正交投影，投影面OXY（裁剪窗口规范化）

## 二维空间消隐示意

![image-20211021192504945](https://cdn.jsdelivr.net/gh/SC-WSKun/HexoStaticFile/img/image-20211021192504945.png)

- 帧缓存：
  - Z-buffer：深度缓存
    - 可以转换成灰度图
    - 存储空间与颜色缓存对应
    - 存储：像素对应的场景中点的z坐标
    - 距离越大离视点越远
  - color-buffer：颜色缓存
    - 存储单元个数 = 显示窗口像素数
    - 存储内容：像素颜色

对每个元素做光栅化，计算每个像素，新得到的深度值比原来的小，则更新颜色缓存

## OpenGL中的消隐函数

1. 为窗口选择深度缓存

   ```c++
   glutInitDislayMode(GLUT_DEPTH|...)
   ```

2. 激活深度测试

   ```c++
   glEnable(GL_DEPTH_TEST)
   ```

3. 设置深度/颜色缓存初始值

   ```c++
   glClearDepth(1.0)/glClearColor(0,0,0,1)
   ```

4. 清楚缓存

   ```c++
   glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT)
   ```

## z-buffer算法*

> z-buffer算法是一种图像空间算法

### z-buffer算法步骤

1. 初始化颜色缓存：

   cbuffer <= 背景色

2. 初始化zbuffer：

   zbuffer <= 视点最远的z值

3. 以任意顺序扫描转换所有多边形

### Z-buffer算法的优点

- 不排序
- 任意集合形状
- 便于硬件加速

### Z-buffer算法的缺点

- 占显存

## 深度排序算法（画家算法）*

> 画家算法是一种对象空间算法，能快速比较多边形的遮挡关系，从远而近地进行绘制
>
> 由于画家算法需要用到排序，则最优复杂度为 o（klogk）

判断顺序：

1. 某个多边形的最小深度值是否大于后面某个多边形的最大深度值，则可以从后往前绘制这两个多边形
2. 当z有重叠时，测试x的范围和y的范围是否有重叠，如果不重叠则可以按任意顺序绘制
3. 有重叠时，可以继续判断是否有交点
4. 如果有交点，可以将多边形进行分割，再试图找到新的绘制顺序

## 二叉空间剖分树*

- BSP树生成算法
- BSP树场景的渲染算法

## 影响消隐算法性能场景类型

- 静态场景
- 静态场景漫游
- 动态场景漫游与交互

## 后向面剔除*

> **原理：**
>
> **作用：**

- V是从视点到物体的视线方向
- n是被测试的多边形法向



- N·V < 0：不可见
- N·V >= 0：可见

![image-20211021202519228](https://cdn.jsdelivr.net/gh/SC-WSKun/HexoStaticFile/img/image-20211021202519228.png)

局限性：

- 对凸多面体场景才能进行完全消隐
- 不能处理遮挡

## 多边形深度排序算法

![image-20211021205808290](https://cdn.jsdelivr.net/gh/SC-WSKun/HexoStaticFile/img/image-20211021205808290.png)

# 光照

## 颜色空间、增色系统、减色系统

- 加色系统（RGB）

  - 主动发光

  - RGB空间（单位立方体）

    ![image-20211028193535438](https://cdn.jsdelivr.net/gh/SC-WSKun/HexoStaticFile/img/image-20211028193535438.png)

- 减色系统（CMY）

  - 吸收光波，反射剩余波长
  - 常用于印刷系统（CMYK）


## 真实感绘制、光照明模型

> 光照明模型考虑物体表面上每一个点所代表的**微小面元**受到来自光源或周围环境光线的照射而产生的**反射或透射**光亮度

### 影响物体表面光照效果的因素

- 光源
- 观察点位置
- 物体表面局部几何形状
- 材质
- 漫反射、高光、透射

### 两类光照明模型*

- 局部光照

  > 局部光照模型受三种光照影响：环境光、漫反射、高光
  >
  > 局部光照模型有三种着色方式：Flat，Gauraud，Phong Shading

  - 泛光模型
  - Lambert 漫反射模型
  - Phong 镜面反射模型

- Whitted 全局光照

#### 局部光照模型

##### 泛光——计算

> 最简单的光照明模型，光强与入射方向和出射方向均无关

![image-20211028200548147](https://cdn.jsdelivr.net/gh/SC-WSKun/HexoStaticFile/img/image-20211028200548147.png)

##### Lambert漫反射模型*

- 直接光源对物体表面的照射有方向性

- 物体表面的反射分为：
  - 漫反射
  - 镜面反射
  
- 纯漫射表面只产生漫反射

- 物体表面相对粗糙

- 入射光线朝各个方向均匀反射

- **强度**
  - 与入射光的光强度和入射方向有关
  - 与漫反射光的反射方向无关
  
- 光强的计算

  ![image-20211215012641398](https://cdn.jsdelivr.net/gh/SC-WSKun/HexoStaticFile/img/image-20211215012641398.png)

  ![image-20211215012711239](https://cdn.jsdelivr.net/gh/SC-WSKun/HexoStaticFile/img/image-20211215012711239.png)

##### Phong 镜面反射模型*

- 镜面反射方向的计算：

  ![image-20211216170326559](https://cdn.jsdelivr.net/gh/SC-WSKun/HexoStaticFile/img/image-20211216170326559.png)

  ![image-20211216170338354](https://cdn.jsdelivr.net/gh/SC-WSKun/HexoStaticFile/img/image-20211216170338354.png)

- 高光反射方向的近似：

  ![image-20211216170458320](https://cdn.jsdelivr.net/gh/SC-WSKun/HexoStaticFile/img/image-20211216170458320.png)

#### 全局光照模型

##### Whitted模型*

- 局部光照明模型的局限
  - 只考虑从光源直接发出的光线对表面光亮度的贡献
  - 不考虑光线在物体之间的相互反射和透射
- Whitted模型：整体光照明模型

### 多边形物体的明暗处理*

- 局部光照计算的简化
  - 效率与准确度的平衡
- 场景表示
  - 多边形网络
- 三类常用的明暗处理方式
  - Flat：面
    - 优缺点：
      1. 处理简单，计算量小
      2. 相邻多边间颜色差异大，存在马赫带效应
  - Gouraud：顶点
    - 优缺点：
      1. 简单快速，生成的图形在真实感上比flat高
      2. 仍旧存在马赫带效应
      3. 不能正确模拟高光
  - Phong：像素
    - 

### 纹理

- 几何纹理
- 颜色纹理
- 各种纹理定义、区分、纹理坐标

#### 纹理映射反走样

## 光线追踪

### 光照模型

全局光照：I=Ic+KsIr+KtIt

### 逆向思想

**三种光线**：

- 来自光源
- 反射方向
- 折射

### 光线跟踪递归终止条件*

- 射线不与任何物体或只与漫反射面相交
- 射线的贡献太小
- 射线达到最大递归深度

# 3D模型

## L-System（过程化建模方式）

- 字符集
- 变量
- 文法规则
- 几何解释

## 粒子系统（过程化建模方式）

- 生命周期
- 粒子生成与消亡
- 基于物理的建模等

## 网格模型

- 半边结构
- 法向量计算

# 物体的几何表示

## **Bezier曲线曲面！！**

![image-20211216184701246](https://cdn.jsdelivr.net/gh/SC-WSKun/HexoStaticFile/img/image-20211216184701246.png)

![image-20211216184713839](https://cdn.jsdelivr.net/gh/SC-WSKun/HexoStaticFile/img/image-20211216184713839.png)

![image-20211216184726966](https://cdn.jsdelivr.net/gh/SC-WSKun/HexoStaticFile/img/image-20211216184726966.png)

## 细分曲线

1. Chaikun细分曲线

   ![image-20211213110316109](https://cdn.jsdelivr.net/gh/SC-WSKun/HexoStaticFile/img/image-20211213110316109.png)

   - 拓扑规则

     - 每条边上插入两个点
     - 插入的点按顺序依次相连

   - 几何规则

     - 计算插入点的位置

       ![image-20211213110946083](https://cdn.jsdelivr.net/gh/SC-WSKun/HexoStaticFile/img/image-20211213110946083.png)

2. 均匀三次B样条细分

   ![image-20211213123710211](https://cdn.jsdelivr.net/gh/SC-WSKun/HexoStaticFile/img/image-20211213123710211.png)

   - 拓扑规则
     - 每条边上插入
     - 一个新顶点
   - 几何规则
     - 顶点点/边顶点计算
     - ![image-20211213111958626](https://cdn.jsdelivr.net/gh/SC-WSKun/HexoStaticFile/img/image-20211213111958626.png)

## 细分曲面

> 给定一个粗网格，通过加入顶点和面得到更细的网格，可以变成：
>
> - 三角网格
> - 四边形网格
> - 混合网格

- 细分模式

  > 细分模式 = 初始网格 + 拓扑规则 + 几何规则

  - 初始化控制网格M0
  - 拓扑规则
    - 插入新顶点、边、面
  - 几何规则
    - 计算新旧顶点的新位置
  - 细分曲面
    - 网格序列Mk的极限

  ![image-20211213112843980](https://cdn.jsdelivr.net/gh/SC-WSKun/HexoStaticFile/img/image-20211213112843980.png)

### Catmull - Clark 细分曲面

- 拓扑规则

  - 每条边加入一个点
  - 每个面加入一个点
  - 原来的顶点保留

  ![image-20211213113939849](https://cdn.jsdelivr.net/gh/SC-WSKun/HexoStaticFile/img/image-20211213113939849.png)

- 几何规则

  ![image-20211213115242037](https://cdn.jsdelivr.net/gh/SC-WSKun/HexoStaticFile/img/image-20211213115242037.png)

### Loop细分曲面

- 拓扑规则
  - 每个三角形一分为四
- 几何规则
  - ![image-20211213123742790](https://cdn.jsdelivr.net/gh/SC-WSKun/HexoStaticFile/img/image-20211213123742790.png)

## 半边结构

- 几何规则
  - 遍历顶点表，计算顶点新位置
  - 遍历半边表，计算边顶点
  - 遍历面表，生成面顶点

## 参数曲线

## 参数曲面

