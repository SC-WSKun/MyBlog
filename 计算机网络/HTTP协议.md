---
title: HTTP协议
date: 2021-11-17 09:13:48
tags: HTTP
categories: 计算机网络 

---

> 参考链接 ：https://segmentfault.com/a/1190000014100927

# HTTP消息结构

## 客服端请求

- 请求行
- 请求头部
- 空行
- 请求数据

![image-20211117092016408](https://cdn.jsdelivr.net/gh/SC-WSKun/HexoStaticFile/img/image-20211117092016408.png)

## HTTP响应

- 状态行
- 消息报头
- 空行
- 响应正文

# HTTP请求方法

## get、post、head

> HTTP1.0的方法

| 方法 | 描述                                                         |
| ---- | ------------------------------------------------------------ |
| get  | 向特定资源发起请求                                           |
| post | 向指定资源提交数据进行数据处理。数据包含在请求体中，post请求可能用于新的资源的创建以及已有资源的修改 |
| head | 类似get请求，不过没有返回体，用于获取包含在响应消息中的元信息 |

## delete、put、connect、trace和options

| 方法    | 描述                                                         |
| ------- | ------------------------------------------------------------ |
| put     | 向指定资源上传最新内容                                       |
| delete  | 请求服务器删除指定资源                                       |
| trace   | 回显服务器收到的请求，用于测试或诊断                         |
| connect | 可以将连接改为管道方式的代理服务器                           |
| options | 返回服务器特定资源支持的http方法，用来向服务器发送“*”的请求来测试服务器的功能性 |

# HTTP头部

## 通用首部

| 首部              | 描述                                                         |
| ----------------- | ------------------------------------------------------------ |
| Connection        | 允许客户端与服务端指定与请求/响应相连接有关的选项            |
| Date              | 提供日期和时间标志，说明报文是什么时间创建的                 |
| MIME-Version      | 向服务端提供MIME版本                                         |
| Trailer           | 如果报文传输采用分块传输，就可以用这个首部列出位于报文拖挂部分的首部集合 |
| Transfer-Encoding | 告诉接受端为了保证报文的可靠传输，对报文采用了什么编码方式   |
| Update            | 给出了发送端可能想要“升级”使用新版本协议                     |
| Via               | 显示报文经过的中间节点（代理、网关）                         |

## Accept首部

| 首部            | 首部                               |
| --------------- | ---------------------------------- |
| Accept          | 告诉服务器能够发送哪些媒体类型     |
| Accept-Charset  | 告诉服务器能够发送哪些字符集       |
| Accept-Encoding | 告诉服务器能够发送哪些编码方式     |
| Accept-Language | 告诉服务器能够发送哪些语言         |
| TE              | 告诉服务器可以使用哪些扩展传输编码 |

## 安全请求首部

| 首部          | 描述                               |
| ------------- | ---------------------------------- |
| Authorization | 包括了客户端提供给服务器的用户数据 |
| Cookie        | 客户端向服务器发送令牌             |
| Cookie2       | 用来说明请求端支持的Cookie版本     |

![image-20211117123704566](https://cdn.jsdelivr.net/gh/SC-WSKun/HexoStaticFile/img/image-20211117123704566.png)

实际应用中，客户端在没有cookie认证前，可以先弹出用户名密码输入界面，将用户名密码发送到服务端进行认证（Authorization）。

服务端发送Cookie到客户端（Set-cookie）

客户端后续请求使用服务端发来的Cookie（没过期的话）

# 状态码

## 信息状态码（100-199）

| 状态码 | 原因短语            | 含义                                                         |
| ------ | ------------------- | ------------------------------------------------------------ |
| 100    | Continue            | 说明收到了客户端的请求初始部分，请客户端继续。发送这个状态码后，服务端在收到请求后必须进行响应 |
| 101    | Switching Protocols | 说明服务器端正在根据客户端的指定，将协议切换为Update首部所列的协议 |

- 使用100场景：客户端有一个较大的文件需要上传并保存，但是客户端不知道服务器是否愿意接受这个文件，所以希望在消耗网络资源进行传输之前，先询问一下服务器的意愿。实际操作为客户端发送一条特殊的请求报文，报文的头部应包含

  ```
  Expect: 100-continue
  ```

  此时，**如果服务器愿意接受，就会返回 100 Continue 状态码，反之则返回 417 Expectation Failed  状态码**。对于客户端而言，如果客户端没有发送实际请求的打算，则不应该发送包含 100 Continue Expect  的报文，因为这样会让服务器误以为客户端将要发送一个请求。

  而对于服务器而言，也不应当把 100 Continue  当作一个严格的判断方法。服务器有可能在发送回应之前就受到了客户端发来的主体报文。此时服务器就不需要再发送 100 Continue  作为回应了。但仍然需要在接受完成后返回适当的状态码。理论上，当服务器收到一个 100 Continue Expect 请求时，**应当进行响应**。但服务器永远也不应向没有发送 100 Continue Expect 请求的客户端发送100 Continue  状态码作为回应。这里提到的应当进行响应是指：**假设服务器不打算接收客户端将要发送的主体报文，也应当做适当的响应（例如发送 417  Expectation Failed）而不是单纯的关闭连接，这样会对客户端在网络层面上产生影响。**

## 成功状态码（200-299）

## 重定向状态码（300-399）

- 301：永久重定向，一般用来做域名跳转
- 302：临时重定向，一般用来做用户未登录的时候进行重定向到登录界面。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的。
- 304：协商缓存，缓存文件未修改

## 客户端错误状态码（400-499）

# HTTP简史

## HTTP0.9

最早提出来的**HTTP0.9**是以简洁为出发点设计的，被称为：只有一行的协议。

**HTTP0.9**实现了：

- 客户端/服务器，请求/响应协议
- ASCII协议，运行于TCP/IP链接之上
- 设计用来传输超文本文档
- 服务器于客户端之间的连接在每次请求之后都会关闭

{% note info %}

**HTTP0.9**的请求只有一行：

```
GET /about/
```

而响应也非常简单，只有一个HTML文档，没有头部，没有其他元数据

所以这个协议只是实现了部分目标而被非官方地称为**HTTP0.9**

{% endnote %}

### HTTP1.0 

**HTTP1.0**在**HTTP0.9**的基础上增加了请求和响应头，而且从超文本转变为超媒体传输，可以传输图像、纯文本文件等等，但是**HTTP1.0**还是保留了**HTTP0.9**的缺点，每次请求响应完成之后都会关闭连接

### HTTP1.1

**HTTP1.1**的出现是因为随着Web应用的发展，体量越来越大，因此HTTP1.0的一些缺点开始暴露出来，比如每次请求都要重新建立连接。这使得Web应用的加载速度不尽如人意。所以**HTTP1.1**的主要目标就是改善**HTTP1.0**的性能

- **增加持久连接：**

  因为HTTP1.0每次请求之前都需要重新连接一次，所以**HTTP1.1**引入了长连接，使Web应用只需要进行一次连接。这样在后续请求中就节省了一个RTT。**HTTP1.1**默认使用长连接，然后1.1还反向升级了1.0，只要1.0在请求头中添加`Connection: keep-alive`就可以进行长连接。

- **管道机制：**

  在拥有长连接之后，还存在一个问题，就是客户端必须等待服务端返回上个请求的响应才会发送下一个请求，那如果服务端在处理完第一次请求后就可以立即处理下一个请求，甚至可以并行处理两个请求，是不是会更快呢？

  所以管道机制的提出就是为了通过尽早分派请求，消除了发送请求和响应的等待时间。客户端不需要等待服务端响应，即可立即向服务端发出请求。

  {% note warning %}

  管道机制的缺陷：

  虽然服务器可以并行处理多个请求，但是在HTTP1.1，服务器必须严格串行地返回响应，这意味着：客户端发来一个HTML请求和一个CSS请求，虽然服务器已经处理完CSS请求，但是必须等待HTML请求处理完毕才能返回，这也就带来了管道机制的一个问题：**队首阻塞**。特别是当前面的请求处理时间过长时，后续完成的请求都要存储在缓冲区里，会占用服务器的大量资源。如果不幸TCP连接中断，则已经处理过的请求需要重复处理第二次，这样带来的代价就过于庞大了，所以在今天，管道机制的使用也并不常见。

  {% endnote %}

- **连接与拼合：**

  > 连接：将多个CSS或JavaScript文件组合为一个文件
  >
  > 拼合：将多张图片组合为一张更大的图片

  由于现代web请求的头部越来越大（因为不会经过任何压缩，特别是有cookie的时候），这时首部相对于内容的开销就会增大，所以我们可以通过连接与拼合来增大一次传输的内容量，从而达到减少请求次数的目的。

- 分块编码传输：服务端每产生一块数据，就发送一块，采用“流模式”取代“缓存模式”

- 增强的缓存机制：

- 传输编码：

- 新增请求方式：参考上文 

## HTTP2.0：更快、更简单、更健壮！

{% note info %}

HTTP2.0的目的就是：

- 通过支持请求与相应的多路复用来减少延迟
- 通过压缩HTTP首部字段将协议开销降至最低
- 增加对请求优先级和服务器端主动推送的支持。

为达成这些目标，HTTP2.0还会给我们带来大量其他协议层面的辅助实现，比如新的流量控制、错误处理和更新机制。

{% endnote %}

- 添加二进制分帧层，实现了完全多路复用：

  

- 完全多路复用：

- 添加请求优先级：

  每个流都有一个31比特的优先值，使客户端和服务器可以在处理不同的流时采取不同的策略。

- 使用报头压缩：

  - HTTP2.0使用"首部表"来跟踪和存储之前发送的键值对，对于相同的数据，不需要再次发送；

  - 首部表在HTTP2.0的连接存续期内始终存在，由客户端和服务器共同渐进地更新
  - 每个新的首部键值对要么被追加到当前表追加到当前表的末尾，要么替换表中之前的值。

- 增加服务器推送：

  - 服务器可以对一个客户端请求发送多个响应（注意服务器必须遵循请求-响应的循环，发送多个响应需要有至少一个请求）。

  - 服务器推送流由PUSH_PROMISE发端，它是除了对原始请求的响应之外，服务器向客户端发出的有意推送所述资源的信号。PUSH_PROMISE帧中只包含要发送的资源的HTTP首部
  - 服务端推送取代了页面嵌入资源，原来的嵌入资源与"强制推送"无异，而客户端在接收到PUSH_PROMISE帧后，可以选择拒绝这个流。



# HTTP3.0：HTTP Over QUIC

>**HTTP2.0**在**1.x**的基础上已经近乎优化到极致了，而**HTTP2.0**现在主要的缺点，来自于TCP的天生缺陷：
>
>- 建立连接时间长
>- 队头阻塞 
>- 移动互联网适应差
>
>因此，要想进一步提高性能，要从TCP下手。因此，谷歌团队使用了**QUIC协议+UDP协议**来替代原来的**TLS协议+TCP协议**，以此解决TCP带来的问题。

![img](https://cdn.jsdelivr.net/gh/SC-WSKun/HexoStaticFile/img/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy93QWtBSUZzMTFxYmVTcnNManVpY1VSMG91bklERHc5QnFURUNFUEdLTG1KUm5NeDBlTGxKS2hkcmljZ29Gd1RIbklSQ1o0VEJBRHg5UDc0aWNyMWJtaWFFMkEvNjQw)

### QUIC协议

> QUIC协议是谷歌开发的，在两个端点之间使用用户数据报协议（UDP）建立多个复用连接来提高正在使用TCP的面向连接的Web应用程序的性能。
>
> QUIC的次要目标包括减少连接和传输延迟，在每个方向进行带宽估计以避免拥塞。它还将拥塞控制算法移动到用户空间，而不是内核空间，此外使用前向纠错（FEC）进行扩展，以在出现错误时进一步提高性能。

那QUCI是如何继承HTTP2.0的优点，又解决了TCP的缺陷的呢？

- 首先QUIC协议**使用流进行传输**：

  是不是听起来很熟悉？没错，就是采用HTTP2.0的方式，在同一个连接中使用多个互不影响的流来解决队首阻塞的问题。

- 0RTT连接：

  1）传输层使用了UDP，减少了1个RTT三次握手的延迟。

  2）加密协议采用了TLS 协议的最新版本TLS 1.3，相对之前的TLS 1.1-1.2，TLS1.3允许客户端无需等待TLS握手完成就开始发送应用程序数据的操作，可以支持1 RTT和0RTT。

  ![2533314564-b21e364c0d3433bf](https://cdn.jsdelivr.net/gh/SC-WSKun/HexoStaticFile/img/2533314564-b21e364c0d3433bf.webp)

- 前向纠错

  
