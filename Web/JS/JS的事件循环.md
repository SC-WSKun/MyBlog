---
title: JS的事件循环
date: 2022-01-17 21:32:42
tags: JavaScript
categories: JavaScript
---

> 看《You Don't Know JS》，一些概念正在更新，这篇博客正在修改中。。。

# 引入

众所周知，JavaScript是一门单线程的非阻塞的脚本语言，目的是为了方便浏览器的交互。

***所以JS引擎在任何时候，都只有一个主线程来处理所有的任务。***

非阻塞的意思是，当代码需要进行一项异步任务（没办法立刻完成，需要一定事件触发）的时候，主线程会挂起这个任务，然后在异步任务返回结果的时候去执行对应的回调。

# 执行栈

当我们调用一个方法的时候，就会生成一个执行上下文，这个执行上下文存着这个方法的私有作用域和上层作用域的指向，方法的参数，这个方法的变量对象以及这个作用域的this。

因为JS是单线程的语言，所以这些方法被排队在一个单独的地方，称为执行栈

执行栈初始为空，当一个脚本第一次执行的时候，JS引擎会解析这段代码，并且将里面的同步代码按顺序加入执行栈中，然后从头开始执行，此时的代码处于全局上下文中。当遇到一个方法的时候，会向执行栈中再添加一个执行上下文，执行完毕返回结果后会销毁这个执行上下文。

上面讲的是同步代码的机制，

# 任务队列

下面讲讲异步代码非阻塞的实现：**任务队列机制**

前面说到，js引擎会将异步事件挂起。当异步事件返回结果执行回调事件的时候，js会将这个事件放到另外一个队列，我们称之为**任务队列**。

任务队列并不会立即执行，而是等待当前执行栈中的所有任务都执行完毕，主线程处于闲置状态时，才会执行事件队列。这样就形成了一个无限的循环。我们称为事件循环

# 宏任务与微任务

> 异步任务也存在优先级，所以js将异步任务分为两类：宏任务和微任务

{% note info %}

宏任务：

- setInterval()
- setTimeout()

微任务：

- new Promise()
- new MutaionObserver()

{% endnote %}

前面我们讲到，异步时间返回结果后会放到一个任务队列中，实际上js会根据这个异步事件的类型，将其放到对应的宏任务队列或者微任务队列。

在执行栈为空的时候，主线程会先查看微任务队列是否有时间存在：

- 如果不存在就会去宏任务队列中取出一个事件加入执行栈。
- 如果存在，则一次执行队列中事件对应的回调，直到队列为空。然后去宏任务队列取出最前面的一个事件加入执行栈

总的来说，执行顺序为：

> 当前执行栈执行完毕时会立刻先处理所有微任务队列中的事件，然后再去宏任务队列中取出一个事件。同一次事件循环中，微任务永远在宏任务之前执行。
