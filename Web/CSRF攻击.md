---
title: CSRF攻击
date: 2021-09-01 22:29:05
tags: 计算机网络
categories: 计算机网络
---

# CSRF 攻击是什么

CSRF（Cross-site request forgery）跨站请求伪造，是指攻击者诱导受害者进入第三方网站，在第三网站中，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目的。

简单来说就是，由于受害者登录过某个网站，有那个网站的通行证。你引导受害者登录你布好陷阱的网站，然后向受害者登录过的网站发送请求，因为请求中携带了受害者的通行证，所以网站会以为是用户执行的操作，达到伪造的目的。

# CSRF 攻击流程

1. 受害者登录 A 网站，并保留登录凭证（Cookie），比如登录了 QQ 邮箱
2. 攻击者引诱受害者访问网站 B，比如一个广告链接
3. 网站 B 向网站 A 发送一个请求，比如"http://A.com?act=..."浏览器会默认携带A的Cookie
4. 网站 A 收到请求后，对请求进行验证，确认是受害者的凭证，误认为是受害者自己的操作
5. A 网站执行 act 参数，比如修改了电子邮箱的自动转发
6. 攻击完成

# 攻击方式

1. 自动发起 GET 请求的 CSRF，比如隐藏在 img 标签的 url 里面
2. 自动发起 POST 请求的 CSRF，使用表单提交，在访问页面时自动提交表单，模拟用户完成一次 POST 操作
3. 引诱用户点击链接的 CSRF，可以隐藏在 a 标签的 url 里，比如一些 sq 广告

# CSRF 产生的条件

1. 目标站点存在 CSRF 漏洞
2. 用户登录过目标站点，并且保持有该站点的登录状态
3. 需要用户打开第三方站点

# 解决方案

1. 设置 Cookie 的 SameSite 属性为 Strict 或 Lax：

   ```
   Strict: 浏览器完全禁止第三方拿到Cookie

   Lax：相对宽松一点，在跨站点的情况下，从第三方站点的链接打开或 Get 方式的表单提交这两种方式都会携带 Cookie；除此之外，如 Post 请求、 img、iframe 等加载的 URL，都不会携带 Cookie（Chrome 80.0的默认值）

   None：任何情况都会发送Cookie数据
   ```

2. 利用同源策略，禁止外域请求
   ```
   在HTTP协议中，每一个异步请求都会携带两个Header，用于标记来源域名
   1. Referer Header : 记录该请求的来源地址（含URL路径）
   2. Origin Header : 记录该请求的域名信息（不含URL路径）
   
   服务器先判断Origin，如果没有Origin属性，再判断是否使用Referer值
   ```
3. Token 认证
